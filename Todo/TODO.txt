Big:

- Build a parse tree for the pattern (lexical and syntactic analysis).

- For the backtracking algorithm (like the .NET Framework's): build an input string matcher capabable of bactracking.

-~For the explicit/implicit DFA algorithms: build a state machine.
-~For the explicit DFA algorithm: transform the NFA state machine into a DFA one (powerset construction).



Features:

- basic language elements (no backtracking): ordinary chars, char escapes, quantifiers, char classes, alternation constructs, anchors, comments, non-capturing grouping

- lazy quantification

- captures and capturing groups

- substitutions

- backreferences

- non-ASCII (Unicode) encodings



Medium:

- handle errors in the pattern string

- implement the explicit DFA algorithm

- implement the backtracking algorithm



Small:

- move CharSubgroup classes from PatternParsers.CharClassPattern to class CharClassPattern (and eliminate the 'let' subexpressions from the pattern definition)

- remove equality operator (==) overloading from classes CharClassPattern and CharRange; maybe also the IEquatable<T> interface and GetHashCode overrides (from all classes)

- A parser should be generic (type-wise) on the determinism/non-determinism of the result, similar to Haskell’s Maybe and List monads, respectively. This is needed because the pattern (the regex language) will be parsed deterministically, whereas the input string, non-deterministically.

* RegexAssert methods: write output to the console (input, pattern, matches)
* do not sort the CharSet and CharRanges array of the CharClassPattern (let the user optimize for speed by choosing the right character order, from most frequent to least frequent in the input)

*oRename Matcher classes to Parser.
