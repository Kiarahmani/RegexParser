Big:

- Build a parse tree for the pattern (lexical and syntactic analysis).

- For the backtracking algorithm (like the .NET Framework's): build an input string matcher capabable of bactracking.

-~For the explicit/implicit DFA algorithms: build a state machine.
-~For the explicit DFA algorithm: transform the NFA state machine into a DFA one (powerset construction).



Features:

- basic language elements (no backtracking): ordinary chars, char escapes, quantifiers, char classes, alternation constructs, anchors, comments, non-capturing grouping

- lazy quantification

- captures and capturing groups

- substitutions

- backreferences

- non-ASCII (Unicode) encodings



Medium:

* character escapes

- quantifiers

- alternation

- handle errors in the pattern string

- implement the explicit DFA algorithm

- implement the backtracking algorithm



Small:

- {n, m} quantifier patterns

- non-greedy quantifiers

- zero-width patterns (for example, "b*" matched against "bbbcc" should return [(0, 3, "bbb"), (3, 0, ""), (4, 0, ""), (5, 0, "")])

- character classes (such as \s, \w, \d) inside a character group (e.g., [abA-Z\d]); also, character escapes (e.g., [\t\u007c]); in fact, parsers CharEscapes and CharClass should be unified

- throw an error for any 'unknown' character after backslash, both in the CharEscapes and the CharClass parsers

- throw an error if \x, \u or \<octal> have too few digits

- escape the dash ('-') inside a character class (e.g., "[a-zA\-Z]" should match only the dash in "BC-DEF")

- test with a char range class pattern inside another one (e.g., @"[[s\]\d]") (or at least it looks that way, even though it's not really interpreted as such)

- add new method to class RegexAssert: ThrowsSameExceptionAsMsoft

- A parser should be generic (type-wise) on the determinism/non-determinism of the result, similar to Haskell’s Maybe and List monads, respectively. This is needed because the pattern (the regex language) will be parsed deterministically, whereas the input string, non-deterministically.

* test with a real newline ("\n") inside a pattern; also, with a verbatim string literal (@"...") that spans two or more lines (as the pattern)
* remove equality operator (==) overloading from classes CharClassPattern and CharRange [maybe also the IEquatable<T> interface and GetHashCode overrides, from all classes]
* move CharSubgroup classes from PatternParsers.CharClassPattern to class CharClassPattern (and eliminate the 'let' subexpressions from the pattern definition)
* RegexAssert methods: write output to the console (input, pattern, matches)
* do not sort the CharSet and CharRanges array of the CharClassPattern (let the user optimize for speed by choosing the right character order, from most frequent to least frequent in the input)
*oRename Matcher classes to Parser.
